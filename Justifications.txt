Justifications:

Diagramme de classe logiciel:
	- Le choix de mettre deux contrôleurs nous semble logique, car il s'agit d'un logiciel qui se veut être manipulé par deux vues différentes: Admin et Client. Un Client ne peut avoir les mêmes pouvoirs qu'un Admin, et un Admin ne souhaite pas effectuer les mêmes actions qu'un Client, mais plutôt gérer le système dans son ensemble.
	- La distinction entre UserController et Client s'est faite selon cette logique; un utilisateur du logiciel n'est pas forcément un client, et peut simplement être à la recherche de renseignements sur les différentes propositions de voyage de notre application, sans pour autant effectuer de Réservation. En effet, un utilisateur est un client seulement lorsqu'il effectue une Réservation pour une Place, donc c'est à ce moment là qu'une entité Client est instanciée, et que le UserController peut avoir accès aux informations client de son compte. On peut imaginer qu'un utilisateur deviendrait un client également lorsqu'il se créerait un compte, sans pour autant avoir effectué une réservation, ce qui instancierait également un objet Client. Mais rien ne fut spécifié dans la consigne à ce sujet.
	- Pourquoi le choix d'un Catalogue ? Dans notre application, pour effectuer une quelconque action, il faut d'abord passer par un catalogue proposant des Liaisons. C'est donc naturellement que s'inclut cette classe Catalogue dans notre design. Exemple: un client souhaite consulter les vols d'un Aéroport A à un Aéroport B ? Il doit d'abord naviguer à travers la liste d'aéroports de l'application pour trouver l'Aéroport A, puis à travers la liste des aéroports connectés à cet Aéroport A pour trouver Aéroport B, et ce n'est qu'à ce moment qu'il pourra y consulter tout les Vol reliant ces deux aéroports, pour éventuellement faire une réservation parmi ces vols, etc... TOUT passe par des tableaux de données, donc il fait du sens de rassembler tout ça dans une classe Catalogue. L'accès et les pouvoirs d'un Admin et d'un Client sur ce Catalogue sera distinct, et c'est pour ça que deux classes différentes seulement y accèdent: AdminController et UserController.
	- Mais… un client veut réserver une Place dans une Liaison. Au vu du diagramme, n'est-ce pas un peu laborieux ? Ne devrions-nous pas passer par une grosse partie des classes du diagramme rien que pour ce faire ? Eh bien oui. Mais, dans un cas réel, c'est comme ça que ça marche. Pour réserver une Place, il faut d'abord nécessairement trouver la Liaison pour laquelle on veut réserver cette place. Rien que pour ça, ça prend au minimum les étapes de l'exemple au dessus. Une fois la Liaison trouver, il faut y sélectionner sa classe/Section, qui dépend du Transport qui se charge de la liaison, et ensuite au sein de cette section, on y réserve sa Place. Est-ce qu'il est possible de raccourcir tout ce trajet vers la réservation, réalistiquement ? Non, car si on faisait cela, le client n'aurait pas toutes les informations entre ses mains pour effectuer une réservation en toute clarté. De plus, une réservation n'est pas une chose qui est sensé se faire tant fréquemment, ni tant rapidement. C'est un dur labeur qui a tout son sens.
	- Et c'est là qu'intervient la classe Client ! Un utilisateur qui est client aura accès à son compte donc à ses réservations, et pourra les consulter facilement et rapidement de par le lien direct. Ainsi, pas besoin de refaire tout le long chemin décrit plus haut pour accéder à ses réservations. Il suffit d'avoir accès au compte avec lequel on a réservé la place: un super shortcut !
	- Héritages: on peut observer que d'un côté, Vol hérite de Liaison, puis qu'Itinéraire et Trajet héritent de LiaisonEscale qui hérite de Liaison. Simplement parce que les liaisons en train et en paquebot on en commun les escales, contrairement au cas de Vol. Similairement, Section se divise en seulement deux sous-classe: SectionDisposable, SectionPaquebot. Cette fois, la similarité se fait entre les voyages en avion et en train, qui peuvent avoir une certaine disposition des sièges. Les trains, nécessairement une disposition étroite alors que les avions, tout un panel. Cela s'explique de par la nature des Places. En effet, dans un Paquebot, les sections contiennent des Cabines, et non des Sièges, comme ses deux homologues. C'est pour cela qu'on fait une nouvelle fois la distinction dans l'héritage de Places: impossible de disposer des Cabines selon la spécification de la consigne, puis ces Cabines peuvent contenir plusieurs personnes, contrairement aux Sièges qui sont limitées à un seul individu. Pour ce qui est du reste des héritages, même si les différentes sous-classes ne semblent pas avoir tant de différences dans leur rôle au sein du logiciel, d'après la spécification, cela pourrait être amené à changer dans les futures itérations, et il serait plus prudent de les distinguer, pour l'heure.